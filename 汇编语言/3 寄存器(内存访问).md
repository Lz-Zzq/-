#### 1.内存中字的存储
>一个字是由两个单元组成,对于字这个单元0号单元是低位,1高位,字型数据4E20H低位存放在0高位1![[汇编语言/img/bb5dea372beb03a698b28ca46936c90.jpg|100]]我们提出字单元的概念:字单元,存放一个字形数据(16位)的内存单元,由两个地址连续的内存单元组成.

#### 2.DS和\[address]
8086cpu中,内存地址由段地址和偏移地址组成,8086cpu中有一个DS寄存器,通常用来存放要访问数据的段地址

**如何读取10000H内容**
>mov bx,1000H
>mov ds,bx
>mov al,\[0]    al8位寄存器
>
><font color = yellow>8086cpu不支持将数值直接放入段寄存器中</font> 
>
>\[...]表示一个内存单元 0代表内存单元中的偏移地址  只有偏移地址是无法定位内存单元的,8086CPU``自动获取ds中的数据为内存单元的段地址
>
>内存单元寄存器都是16进制数表示,但是16进制数被传送到内存单元,对应的是可显示的ASCII码,如果没有Debug就用 . 来代替

**数制讨论**
>通常来说都是以二进制数表示的,但是为了描述不同问题,又经常使用其他数制表示

使用mov指令访问内存单元,可以在mov指令中只给出单元的偏移地址,此时段地址在DS寄存器中

**如何将寄存器中的数据放入到内存单元中?**
>内存单元中的数据放入寄存器格式: mov寄存器名,内存单元地址
>寄存器数据放入内存单元中的格式: mov内存单元地址,寄存器名
>
>mov bx,1000
>mov ds,bx
>mov \[5] ,al  ##将al(8bit)中的数据放入到 10005内存地址中

#### 3.字的传送
前面讲到了寄存器与内存之间进行字节型数据的传送,对于字的传送我们只需要在mov指令中给出16位寄存器就可以进行16位数据的传送了
>mov bx,1000
>mov ds,bx
>mov \[5] ,ax  ##将ax(16bit)中的数据放入到 10005内存地址中
![[汇编语言/img/9720edb2c6b19d28ed7c346f8d67cf5.jpg|400]]
#### 4. mov add sub 指令
<font color=yellow>既然有 mov 段寄存器,寄存器 就有 mov寄存器,段寄存器
既然有 mov 内存单元,寄存器 就有 mov内存单元,段寄存器
mov段寄存器,内存单元也一样可行

add sub他们无法对段寄存器操作
add ax,bl 非法的计算</font>
![[汇编语言/img/4aa498a8fd001bf43075318e3bb81ac.jpg]]

#### 5. 数据段
对于8086PC机,可以根据需要将一组内存单元定义为一个段.我们可以将一组长度位N(N<=64KB)地址连续,起始地址为16的倍数的内存单元当作专门的存储数据空间比如
123B0-123B9 这是一个数据段段地址123B 长度10字节

**将数据段123B0-123B9内存单元定义为数据段**
>mov ax,123B
>mov ds,ax
>mov al,0
>add al,\[0]
>add al,\[1]
>add al,\[2]

**数据段中累加字型数据**
>mov ax,123B
>mov ds,ax
>mov ax,0
>add ax,\[0]
>add ax,\[2]
>add ax,\[4]

#### 6.栈
8086提供了入栈出栈指令,最基本的两个是PUSH(入栈)POP(出栈) 
8086CPU入栈出栈都是<font color = yellow>字为单位的</font>

**CPU是如何知道某一段空间被当作栈使用的?**
**push,pop在执行的时候,必须知道哪个单元是栈顶单元,可是,如何知道的?**
>8086有两个寄存器,<font color = yellow>段寄存器SS</font>和<font color = yellow>寄存器SP</font>,栈顶地址存放在SS,偏移地址SP中,任意时刻,SS:SP指向栈顶元素.push与pop执行时,cpu从ss与sp获取栈顶地址![[汇编语言/img/29ece9e5f78da41c5c84a338c80aab3.jpg| 390]]从图中我们可以看到,8086CPU中,入栈时,栈顶从高地址向低地址方向增长

**如果将10000H-1000FH当作栈,SS=1000H SP=?**
>SP = 1000e = e - 2 = 10 = 0010H
>栈空,SS:SP指向栈空间最高地址单元的下一个单元,栈空间大小16字节,最底部的字单元地址1000:000E,栈为空,就相当于唯一元素出栈,SP=SP+2 0010H
![[汇编语言/img/ad677b80f27ac3842e7982f0f552b26.jpg| 400]]

**pop指令的功能**
两步完成
>将SS:SP 指向的内存单元处的数据送入ax中
>SP=SP+2,SS:SP指向当前栈顶下面的单元,以当前栈顶下面的单元为新栈顶
![[汇编语言/img/db30cbbe4744b24c6782a898eaa77cd.jpg| 400]]
 注意,SS:SP指向新的栈顶1000EH,pop操作前的栈顶元素,<font color = yellow>1000CH处的2266H依然存在,但是他已经不在栈中</font>.当再次执行push等入栈指令后,SS:SP移动到1000CH,并在里面写入新的数据进行覆盖.

#### 7.栈顶超界问题
![[汇编语言/img/f9fa46947c58f2310ca8b641f764b53.jpg| 400]]当再次执行pop ax: sp=sp+2, SS:SP指向10022H,栈顶超出了占空间,如果在执行push,10020H,10021H中的数据就会将被覆盖

8086CPU不保证我们对栈的操作会不会越界,也就是说,他只考虑当前的情况,.栈顶超界是非常危险的

#### 8. push pop指令
显然push与pop指令是可以在寄存器和内存(栈空间当然也是内存空间的一部分,他只是一段可以以一种特殊的方式进行访问的内存空间)之间传送数据的
**push与pop指令的格式可以是如下形式:**
>push 寄存器    将一个寄存器中的数据入栈
>pop   寄存器    用一个寄存器接收出战的数据
>
>push 段寄存器    将一个段寄存器中的数据入栈
>pop   段寄存器    用一个段寄存器接收出战的数据

**push与pop也可以在内存单元之间传送数据**
>push 内存单元    将一个内存单元中的数据入栈
>pop   内存单元    用一个内存单元接收出战的数据
>
>比如:
>mov ax,1000H
>mov ds,ax
>push\[0]    将10000位置的字压入栈中
>pop \[2]    将栈中数据放入1000:2中

==push,pop实质上就是一种内存传送指令,可以在寄存器和内存之间传送数据,与mov指令不同的是,push,pop指令还要改变SP中的内容==

==改变SP后写入内存的入栈指令,读内存后改变SP的出栈指令==

**栈的综述**
>SS,SP中存放栈顶的段地址与偏移地址'
>push指令的执行步骤: SP=SP-2 向SS:SP指向的字单元中送入数据
>pop指令的执行步骤:从SS:SP指向的字单元中读取数据 SP=SP+2
>任意时刻,SS:SP指向栈顶元素
>

#### 9. 栈段
一组连续的内存定义成为一个段,长度为N(N<64KB) 的一组地址连续,起始地址为16的倍数的内存单元,当作栈空间使用,从而定义了一个栈段

**10000H-1FFFFH这段空间作为栈,空栈,SS=1000H,SP?**
> SP原来位置在1FFFEH,+2后20000所以SP=0000
> 任意时刻,SS:SP指向栈顶元素,空栈没有元素不存在栈顶,所以指向最下面的单元,该单元地址为栈最底部字单元地址+2

**一个栈段最大容量可以设置为多少?为什么?**
>push pop指令在执行的时候只修改SP,所以栈顶的变化范围是0-FFFFH,栈空SP=0,一直压栈,栈满再次压栈栈顶将环绕,覆盖了原来栈中的内容,最大容量是64KB

**段的综述**
>一个段可以被定义为,数据段,代码段,栈段
>
>CPU按照我们的安排来访问这些段,就要:
>**==数据段: 将他的段地址放在DS中==**,用mov add sub 等访问内存单元的指令时,CPU就将我们定义的数据段中的内容当作数据来访问
>==代码段: 将他的段地址放在SS中==,将段中的第一条指令的偏移地址放在IP中,这样CPU就将执行我们定义的代码段中的指令
>==栈段: 他的段地址放在SS中==,将栈顶单元的偏移地址放在SP中,这样CPU在需要进行栈操作的时候,比如执行push pop等指令,就将我们定义的栈段当作栈空间来使用

#### 实验2 用机器指令与汇编指令编程

**Debug在执行 d 1000:0 这样的命令也会先将1000H先放入段寄存器中**
>段寄存器存在4个 CS DS SS ES 送入哪一个呢
>首先cs不行，因为CS要指向当前执行d命令的地址，SS也不行，SS要指向栈顶
>mov ax,\[0] 一般都默认段地址在ds中，在debug执行 “d 段地址：偏移地址”这种命令时候，将段地址放入ds中比较方便

**D命令也提供了一种符合CPU机理的格式 “d 段寄存器：偏移地址”**
> -r ds
> :1000
> -d ds : 0       查看1000：0内存区间中的数据
> 
> -r ds
> : 1000
> -d ds : 10 18    查看1000：10 - 18 的数据
> -d cs : 0      查看当前代码段中的指令代码
> -d ss : 0      查看当前栈段中的内容
> 
> E,A,U 这些带有内存单元地址的命令中，也可以一样用段寄存器表示内存单元的段地址
> -e ds:0 11 22 22 22   ds:0 内存中写入数据
> -u cs:0      汇编指令性是显示当前（cs:0）中的代码
> -a ds:0    在ds:0处向内存中写入汇编指令


**mov sp,10去哪里了?**
>![[汇编语言/img/Pasted image 20240725141110.png]]![[汇编语言/img/Pasted image 20240725141413.png]]在使用T命令执行mov ss,ax的时候,它的下一条指令mov sp,10 也紧接着执行了
>不单是mov ss,ax 对于 mov ss,bx，mov ss\[0]，pop ss 等指令都会发生这种情况
>因为他们都是修改栈段寄存器SS的指令。==Debug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着执行，中断机制==

中断发生时候，下一条指令的CS:IP中的值就是需要记录的值，我们就需要保存起来，放到栈堆中,所以栈中的值就被改变了。
```
mov ax, 2000
mov ss, ax – > 发生中断，然后，会保护现场
mov sp, 10
mov ax,3123
```
