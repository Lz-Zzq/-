#### 1. 源程序从写出到执行的过程
第一步： 编汇编程序
第二部： 对源程序进行编译连接
使用汇编语言编译程序对**源程序**文件中的源程序进行**编译**，产生**目标文件**；再用**连接程序**对目标文件进行连接，生成可在操作系统中直接运行的**可执行文件**

可执行文件包含两部分内容
- 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
- 相关的描述信息（比如，程序有多大，要占用多少内存空间）
第三步： 执行可执行文件
操作系统按照可执行文件的描述信息，将可执行文件中的机器码和数据加载内存，并进行相关的初始化（比如设置CS:IP指向第一条要执行的指令），然后由CPU执行程序

#### 2. 源程序
```
assume cs:code
codesg segment
		mov ax,0123H
		mov bx,0456H
		add ax,bx
		add,ax,ax
		
		mov ax,4c00H
		int 21H
codesg ends
end
```

**1.伪指令**
在汇编语言程序中，包含两种指令，一种是汇编指令，一种是伪指令，汇编指令有对应的机器码指令，可以被编译为机器指令，最终被CPU执行，而伪指令没有对应的机器指令，最终不被CPU执行，伪指令是由编译器来执行的指令。

```
XXX（段名） segment
	....
XXX（段名） ends 段结束

sengment ends是一对伪指令，定义一个段
一个有意义的汇编程序中至少要有一个段，这个段用来存放代码
```

```
end
汇编程序结束标记，缺失的话程序无法知道何时终止assume

assume
"假设" ，假设某一段寄存器和程序中的某一个用segment....ends定义的段关联。在需要情况下，编译程序可以将段寄存器和某一个具体的段相关联

例如：
我们用codesg sement ... codesg ends 定义了一个名为codseg的段，这是一个代码段，程序的开头我们使用了assume cs:codesg将用代码段的段codesg和CPU中的段寄存器CS联系起来
```
**2.源程序中的“程序”**
源程序中的汇编指令组成了计算机最终执行的程序，源程序中的伪指令是由编译器来处理的，并不实现先我们编程的最终目的。这里所说的程序就是源程序中最终由计算机执行，处理的指令或者数据。

源程序文件中的所有内容称之为源程序，其中最终由计算机执行处理的指令或者数据称之为程序，程序先以汇编指令的形式在源程序中，经编译，连接后转为机器码，存储在可执行文件中
![[汇编语言/img/b2d8691ebf407ed5651e87417480dce.jpg|400]]
**3.标号**
>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如“codesg”，一个标号代表了一个地址。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译，连接程序处理为一个段的段地址。

**4.程序的结构**
```
assume cs:abc  将abc与cs联系起来
 abc segment 段头

.....      汇编指令

abc ends 段尾
end 结束
```
**5.程序返回**
我们的程序最先以汇编指令的形式在源程序中，经编译，连接后转变为机器码，存储在可执行文件中，他是怎么运行的呢？

一个程序P2在可执行文件中，则必须有一个正在运行的程序P1，将P2从可执行文件中加载如内存后，将CPU的控制权交给P2，P2才能运行，P2开始运行后，P1暂停运行

一个程序结束后，将CPU的控制权交还给使他得以运行的程序，这个过程就是程序返回
![[汇编语言/img/d0893ff9e59f71a4e39563264fd5be4.jpg]]

#### 3.编译
使用任意文本编辑器编写代码，改名为.asm
使用DOS方式运行masm.exe
![[汇编语言/img/Pasted image 20240727115702.png| 400]]
>第一行：.ASM代表默认扩展名是asm，如果是1.asm只需要输入路径与1就可以了
如果源我呢见不是asm为扩展名的话，就要输入全名
第二行：提示我们编译出的目标文件的名称，目标文件是我们对一个源程序进行编译要得到的最终结果。屏幕上的1.OBJ，因为我们已经输入了源程序文件名1.asm，则编译程序默认要输出的文件名为1.obj
第三行：提示输入列表文件的名称，这个文件是编译器将源程序编译为目标文件过程中产生的中间结果。
第四行：提示出入交叉引用文件的名称，这个文件同列表文件一样，是编译器将源程序编译为目标文件过程中产生的中间结果。
编译结束：没有异常情况，编译通过。一般有两类错误使我们得不到所期望的目标文件
1.程序中有Server Errors
2.找不到所给出的源程序文件

**在编译过程中，我们提供了一个输入，最多可以得到三个输出：**
==目标文件(.obj) 列表文件(.lst) 交叉引用文件(.crf)==

#### 4.连接
![[汇编语言/img/Pasted image 20240727125626.png]]
>第一行：进入DOS，运行link.exe，首先显示一些版本信息，然后提示输入将要被连接的目标文件名称。.OBJ提示我们默认OBJ扩展名，如果其他名称输入全名
第二行：程序提示我们输入生成的可执行文件名称，默认1.exe
第三行：连接程序提示输入映像文件的名称，这个文件是连接程序将目标文件连接为和执行文件过程中产生的中间结果
第四行：连接程序提示库文件名称。库文件里面包含了一些可调用的子程序，如果程序中调用某一个库文件中的子程序，就需要在连接的时候，将这个库文件与目标文件连接到一起，生成可执行文件。
第五行：对目标文件的连接结束，连接程序输出告诉我们这个程序有一个警告错误：“没有栈段”

**连接的作用**
>1.当源程序很大时，可以将他分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将他们链接到一起，生成一个可执行文件。
2.程序中调用了某个库文件的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件
3.一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以就算只有一个源程序文件，也不需要调用子程序的情况下，也必须使用连接程序对目标文件进行处理，生成可执行文件。

#### 4.以简化的方式进行编译连接
```
masm 1.asm
link 1
自动忽略中间文件的生成，在当前目录下生成可执行文件
```
#### 5.谁将可执行文件中的程序将在进内存并使他运行?
**1.有一个运行的程序将1.exe中的程序加载到内存，这个正在运行的程序是什么？
他将程序加载到内存后，如何使得程序得以运行？**
>DOS中有一个程序command.com，这个程序在DOS中称之为解释器，也就是DOS中的shell（外壳，操作系统中给操作人员使用的程序，来操作计算机系统进行工作）
>
>DOS启动时，先完成其他重要的初始化工作，然后运行command，随后就显示我们打开DOS看到的界面了
>
>如果用户需要执行程序，输入可执行文件名称，command首先根据文件名找到可执行文件，然后将这个可执行文件加载到内存，设置CS:IP指向程序入口。command暂停运行，CPU运行程序。运行结束后返回到command。
>
>在DOS中，command处理各种输入：命令或者要执行的可执行程序文件名。
>
>所以，DOS直接运行1.exe 是正在运行的command将1.exe加载到内存
>command设置CPU的CS:IP指向程序的第一条指令（程序入口），从而使得程序运行

**2.运行结束后，返回到了哪里？**
>运行结束后，返回到command中，CPU继续运行command

**汇编程序从写出到执行的过程**
```
编程 -> 1.asm -> 编译 -> 1.obj -> 连接 -> 1.exe -> 加载 -> 内存中的程序 -> 运行
(Edit)                    (masm)                (link)                   (command)                       (CPU)
```
#### 6.程序执行过程中的跟踪
为了观察程序的运行过程，可以使用Debug。Debug可以将程序加载到内存，设置CS:IP指向程序的入口，但Debug并不放弃对CPU的控制，这样，我们就可以使用Debug相关命令来单步执行程序，查看每一条指令执行的结果。
![[汇编语言/img/Pasted image 20240729104654.png]]
可以看到，Debug将程序从可执行文件加载入内存后，cx中存放的是程序的长度。1.exe中程序的机器码共有15个字节。则1.exe加载后，cx中的内容为000FH。
![[汇编语言/img/a24c7cf68e42ad7d1439f4b5995f308.jpg| 500]]注意，有一步称之为重定位的工作在图中没有讲解，这个问题与操作系统的关系比较大，我们不做讨论。

**程序被装入内存的什么地方？我们如何得知？**
>1.程序在加载后，ds中存放着程序所在的内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds:0
>2.这个内存区的前256个字节中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。
>所以，从ds中可以得到PSP的段地址SA，PSP的偏移得知为0，则物理地址为SAx16+0

因为PSP占256（100H）字节，所以程序的物理地址是：
>SA x 16 + 0 + 256 = SA x 16 + 16 x 16 + 0 = (SA+16) x 16 +0
>可用段地址和偏移地址表示为：SA+10H:0

==T命令单步执行==
==执行到int 21要使用P命令执行==

在DOS中运行程序时候，是command将程序加载入内存，所以程序运行结束后返回到command中，而这里使用debug将程序放入内存，所以运行结束后要返回到debug中。
使用q命令退出debug，将返回到command中，因为debug是command加载运行的
