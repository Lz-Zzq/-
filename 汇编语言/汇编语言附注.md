# 附注1 Intel系列微处理器的3种工作模式
Intel系列微处理器的主要发展过程是：8080，8086/8088，80186，80286，80386，80486，Pentium，Pentium II，Pentium III，Pentium4。
8086/8088不具备实现一个完善的多任务操作系统功能，因此Intel开发了80286，虽然支持多任务，但是对8086/8088兼容性做的不好。

随后Intel又开发了80386微处理器，这是一个划时代的产品，可以在3个模式下工作。
**1.实模式**：工作方式相当于一个8086
**2.保护模式**：提供支持多任务环境的工作方式，建立保护机制（这与VAX等小型机类似）
**3.虚拟8086模式**：可以从保护模式切换至其中的一种8086工作方式。这种方式的提供使用
户可以方便的在保护模式下运行一个或多个8086原程序。

任何一台Intel系列CPU只要PC机一开，CPU就在实模式下运行。如果是windows，windows加载后将由Windwos将CPU切换到保护模式下工作，因为windows是多任务系统，必须在保护模式下运行。如果在windows种运行一个dos下的程序，那么windows将cpu切换到虚拟8086模式下运行该程序。

可以从保护模式直接进入到运行原8086程序的虚拟8086模式是很有意义的，80826缺陷在于，只提供了实模式和保护模式，但没有提供虚拟8086。这导致不能方便的运行8086系统中的程序，如果还要运行8086程序就要重启计算机，让CPU在实模式下运行

幸运的是windows是基于80836的，我们可以轻松的工作，开两个窗口，一个工作与保护模式的word，一个是工作与虚拟8086模式的DBASE，我们切换他们只需要点击即可。

我们学习汇编语言在实模式下运行，因为保护模式十分复杂。

# 附注2 补码

以8位的数据为例，对于无符号数来说是从00000000b~11111111b到0~255一一对应的。
考虑8位数据的最高位来表示符号，1表示负，0表示正
```
00000000b : 0
00000001b : 1
00000010b : 2
01111111b : 127
10000000b : ?
10000001b : -1
10000010b : -2
11111111b : -127
```
可以表示-127~127，254个有符号数，从这里我们看出问题，表示少了一个

再考虑反码，选确定用00000000~011111111b表示0~127，然后再用它们按位取反后的数据表示负数。
```
00000000b : 0               11111111b : ?
00000001b : 1               11111110b : -1
00000010b : 2               11111101b : -2
01111111b : 127           10000000b : -127
```
同样问题

采用补码，先确定00000000~01111111b 表示 0~127，然后再用他们按位取反加1后的数据表示负数。
```
00000000b : 0              11111111b+1=00000000b : 0
00000001b : 1              11111110b+1=11111111b : -1
00000010b : 2              11111101b+1=11111110b : -2
01111111b : 127          10000000b+1=10000000b : -127
```
1.最高位为1，表示负数
2.正常的补码取反加1后，为其对应的负数的补码：复数的补码取反加1后，为其绝对值。
比如：
**1的补码为：00000001b,取反加1后为：11111111b，表示为-1**
**-1的补码为：11111111b，取反加1后为：00000001b，绝对值为1**

我们从一个负数的补码不太容易看出他表示的数据，比如11010101b表示的数据是多少？
利用补码特性，将11010101b取反后+1，=00101011 可以知道11010101b表示的负数的绝对值为 2BH，就知道11010101b表示的负数为-2BH

那么-20补码是多少
补码特性: -20绝对值20，00010100b，将其取反+1  = 1110110，补码就是11101100；
**负数的补码就是正数补码取反+1，然而正数三码合一**
详见参考链接 [[原码_反码_补码_位运算]]

那么10000000b表示多少呢？
10000000b 取反后+1 10000000b大小为128，所以==10000000表示-128==

# 附注3 汇编编译器(masm.exe)对jmp的相关处理

# 附注4 用栈传递参数
例子：
计算(a-b)^3 a,b为字型数据
参数：进入子程序时，栈顶存放IP，后面依次存放a，b
结果：（dx：ax）=（a-b）^3 

```
difcube : push bp
	mov bp,sp
	mov ax,[bp+4]
	sub ax,[bp+6]
	mov bp,ax
	mul bp
	mul bp
	pop bp
	ret 4
	-------------ret 4 的含义就是 pop IP      add sp,n
```
因为用栈传递参数，所以调用者在调用程序的时候要向栈中压入参数，子程序在返回的时候可以用ret n指令将栈顶指针修改为调用前的值。调用上面的子程序之前，需要压入两个参数，所以用ret 4返回。
```
mov ax,1
push ax
mov ax,3
push ax
call difcube
```
C程序
```
void add(int,int,int)

main(){
	int a=1;
	int b=2
	int c=0
	add (a,b,c)
	c++;
}

void add(int a,int b,int c){
	c=a+b
}
```
编译后的汇编程序
```
mov bp,sp
sub sp,6
mov word ptr [bp-6],0001   ;int a
mov word ptr [bp-4],0002   ;int b
mov word ptr [bp-2],0000   ;int c
push [bp-2]
push [bp-4]
push [bp-6]
call ADDR
add sp,6
inc word ptr [bp-2]

ADDR:
	push bp
	mov bp,sp
	mov ax,[bp+4]
	add ax,[bp+6]
	mov [bp+8],ax
	mov sp,bp
	pop bp
	ret
```
# 附注5 公式证明
问题：计算X/n(X<65536\*65536,n!=0)
在计算过程中保证不会出现除法溢出
分析：
1.在计算过程中要保证不会出现除法溢出。
分析：
也就是说，商要小于65536
设：X/n(H\*65536+L)/n=(H/n)\*65536+(L/n)
H=int(X/65536)
L=rem(X/65536)
因为H<65536，L<65536 所以
2.将计算X/n分解为计算：
(H/n)\*65536+(L/n);   H=int(X/65536);  L=rem(X/65536)
DIV指令只能得出余数和商，而我们只保留商。余数必然小于除数，一次正确的除法运算只能丢掉一个余数。

