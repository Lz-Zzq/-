#### 1. CPU
 >  运算器: 信息处理
  > 寄存器 : 信息存储
  > 控制器 : 控制器控制各种器件进行工作
  > 内部总线 : 连接各种器件,在他们之间进行数据传送
#### 2. 通用寄存器
>   8086CPU所有CPU都是16位,可以存放两个字节,被称之为通用寄存器
>   16位寄存器可以存放 ${2}^{16}$ 位 最大值为${2}^{16}$-1

![[汇编语言/img/ea4abc0dbaae77d1245a5f0d95eb049.jpg]]
#### 3. 字在寄存器中的存储
> <font color = yellow>字节</fon> : Byte 8bit
> <font color = yellow>字</font> : word 两个字节组成 高位字节与低位字节
#### 4. 高位舍弃
  >add ax,bx ax=bx=8226  高位舍弃 ax = 044C
  >   al(8位低位寄存器) add al,93H  ax=00C5 al=C5  高位舍弃ax=0058(不能在8位寄存器中保存,但是CPU不会真的丢弃该值)  

#### 5. 地址加法器
  >8086CPU存在20位地址总线,16位结构CPU在内部一次性处理,传输,暂时存储的地址为16位,ta是通过地址加法器来实现20位的物理地址的![[汇编语言/img/e31e54f6467a0f6f2f99ac204a36626.jpg| 400]]
>	1. 一个数据的二进制形式左移1位,相当于该数据乘以2
>	2. 一个数据的二进制形式左移N位,相当于该数据乘以2的N次方
>	3. 地址加法器如何完成段地址x16的运算,就是将二进制形式存放的段地址左移4位

#### 6. 段地址x16+偏移地址=物理地址的本质含义
>本质含义是: CPU在访问内存时,用一个基础地质(段地址x16)和一个相对于基础地址的偏移地址相加,给出内存单元中的物理地址. 更一般的说是一种具体实现的方案
#### 7. 段的概念
>内存没有分段,段的划分来自于CPU,因为8086cpu采用"基础地址(段地址x16)+偏移地址=物理地址"的方式给出内存单元的物理地址,让我们可以分段的方式来管理内存

>在编程时可以根据需要,将若干地址连续的内存单元看作一个段,用段地址x16定位段的起始地址(基础地质),用偏移地址定位段中的内存单元

>有两点需要注意: 段地址x16一定是16的倍数,所以段的起始地址也一定是16的倍数;
>偏移地址是16位,16位地址寻址能力64kb所以一个段长度最大64kb

#### 8.段寄存器 CS与IP
>8086CPU存在<font color=yellow>四个段寄存器: CS DS SS ES </font>当要访问内存时由这四个段寄存器提供内存单元段地址

>CS与IP指示了当前CPU区指令的地址 
>CS指令存放指令的段地址,IP存放指令的偏移地址
>![[汇编语言/img/6876022f2576eb713dffe8dc699a079.jpg| 400]]1. 从CS:IP指向的内存单元读取指令,读取的指令进入指令缓冲器
>2. IP = IP+所读取指令的长度,从而指向下一条指令
>3. 执行指令,转到步骤(1),重复这个过程
>在8086加电启动或者复位后(CPU刚开始工作时) CS 与 IP 被设置为CS = FFFFH
>IP=0000H 8086刚启动时,CPU从内存FFFF0H单元中读取指令执行,FFFF0H单元中的指令是8086开机后执行的第一条指令

**CPU根据什么将内存中的信息看作指令?**
>CPU将CS:IP指向的内存单元中的内容看作指令,CS,IP中的内容当作指令的段地址和偏移地址,用他们合成指令的物理地址,到内存中读取指令码执行,一段信息曾经被CPU执行过,那么他所在的内存单元必然被CS:IP指向过

#### 9. 修改CS IP 指令
在CPU中,程序员能够用指令读写的部件只有寄存器
<font color = yellow>jmp指令可以修改CS IP</font>
若想同时修改CS IP 指令可用形如 jmp 段地址:偏移地址如
>jmp 2AE3:3   CS = 2AE3H IP=0003H CPU将2AE33H处读取指令

若想修改IP内容,可用"jmp某一合法寄存器"的指令完成
jmp ax 执行指令前: ax=1000H, CS=2000H, IP=0003H
jmp ax 执行指令后: ax=1000H, CS=2000H, IP=1000H
jmp bx 执行指令前: bx=0B16H, CS=2000H, IP=0003H
jmp bx 执行指令后: bx=0B16H, CS=2000H, IP=0B16H

#### 实验1 查看CPU和内存,用机器指令和汇编指令编程
>用Debug的R命令查看、改变CPU寄存器的内容![[汇编语言/img/Pasted image 20240720202240.png]]

>用Debug的D命令查看内存中的内容: 用Debug的E命令改写内存中的内容；![[汇编语言/img/Pasted image 20240720202822.png]]使用d 段地址:偏移地址的格式debug列出了128个内存单元的数据 中间的-便于查看
>左边每行是起始地址 右边每个内存单元中的数据是可显示的ASCII码符 接着使用d命令就可以列出后续的内容
>也可以指定查询范围 例如查看1000:0-1000:9    d 1000:0 9  就会显示这九个字符

>用Debug的E命令改写内存中的内容；![[汇编语言/img/Pasted image 20240721135844.png]] 一种方式是直接在后面写入需要改写的内容
>另一种方式就是一个一个的写入空格代表继续写入,enter代表退出

>用Debug的U命令将内存中的机器指令翻译成汇编指令；![[汇编语言/img/Pasted image 20240721140534.png]]1000:70 存放的机器码是 b8 01 00 指令 mov ax,1
>1000:73 存放的机器码是 b9 02 00 指令 mov cx,2
>1000:76 存放的机器码是 01 c8 指令 add ax,cx

>用Debug的T命令执行一条机器指令； ![[汇编语言/img/Pasted image 20240721143715.png]]修改CSIP的指向,指向我们存放指令的地址 使用T命令执行指令

>用Debug的A命令以汇编指令的格式在内存中写入一条机器指令
>![[汇编语言/img/Pasted image 20240721144109.png]]![[汇编语言/img/Pasted image 20240721144131.png]]设置起始地址或者直接使用-a开始以汇编指令往内存中写入机器指令

>0-9FFFF就是内存单元中读取数据,就是读取主随机存储器中的数据
>A0000-BFFFF的内存单元中写入数据就是写入到显存=
>C0000-FFFFF写入操作无效,因为等于改写只读存储器中的内容
>![[汇编语言/img/28ad8799026ea1ccda50b0e3a4552bf.jpg|200]]
