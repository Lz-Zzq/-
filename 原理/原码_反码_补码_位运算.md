# 进制转换
```c
其他转换10进制 *
二进制转换10进制   位数 * 2 (位数-1次方)
八进制转换10进制   位数 * 8 (位数-1次方) 
	014  =  4 * 8 (0次方)   4 * 8 (1次方)         4 + 8 = 12
十六进制转换10进制 0 任何次方都是1   1 任何次方都是本身
	0x23A = 10 * 16 (0) 3 * 16 (1) 2 * 16 (2) = 10 + 48 + 512 = 570

十进制转换其他
十进制转换二进制 
	/2   34 / 2 - 0   17 / 2 - 1   8/2 - 0   4 / 2  - 0  2 / 2 - 0   底1  =  100010
十进制转换八进制 
	/8   131/8 - 3   16/8 - 0   2 =  203
十进制转换16进制 
	/16  237/16 - 13  14   ED

二进制转换其他 3_4位一组
二进制转换八进制 
	三位一组 11_010_101 => 0325
二进制转换十六进制 
	四位一组 1101_0101 => 135 => D5

其他转二进制 3_4位一组
八进制转换二进制 
	0325 => 3(011)2(010)5(101) => 011_010_101
十六进制转换二进制 
	D5 => 13(1101)5(0101) => 1101_0101
```
# 原码 反码 补码
```c
1.二进制的最高位是符号位: 0表示正数 1表示负数
2.正数的原码,反码,补码都一样(三码和一)
3.负数的反码=它的原码符号位不变,其它位取反
4.负数的补码=它的反码+1,负数的反码=负数的补码-1
5.0的反码补码都是0
6.计算机以补码运算,看结果看原码

回溯点：负数的补码=这个数绝对值二进制数取反+1得到补码（负数）

按位与&        : 两位全为1,结果为1,否则0  两个都为1
按位或|          : 两位一个1,结果为1,否为0  只要有1
按位异或^     : 两位一个为0一个为1,结果为1,否则为0  两位不相等
按位取反~     : 取反

1.得到2的补码 =>
	原码 00000000 00000000 00000000 00000010 => 正数三码和一
2.得到3的补码 => 
	00000000 00000000 00000000 00000011 
	 & 两个都为1才是1
00000000 00000000 00000000 00000011
00000000 00000000 00000000 00000010  => 00000000 00000000 00000000 00000010
printf("%d\n",2&3); // 2

1.得到-2的补码 
	=> 原码 10000000 00000000 00000000 00000010 
	=> 反码 11111111 11111111 11111111 11111101
	=> 补码  11111111 11111111 11111111 11111110
	~ 取反  00000000 00000000 00000000 00000001 [正数] 三码和一 原码
printf("%d\n",~-2); // 1

1.得到2的补码 => 
	补码 00000000 00000000 00000000 00000010 [三码和一]
	~ 取反  11111111 11111111 11111111 11111110 运算后的补码
	取到原码 [负数,非三码和一,需要转换,先求出反码,对反码在进行反码=原码]
	=> 负数反码=补码-1   11111111 11111111 11111111 11111100
	=> 原码=对反码再次取反 10000000 00000000 00000000 00000011
printf("%d\n",~2); // -3

1.得到 2 3 的补码  
	00000000 00000000 00000000 00000010    00000000 00000000 00000000 00000011
2.只要有一个为1   
	00000000 00000000 00000000 00000011
printf("%d\n",2|3); //3

1.得到 2 3 的补码  
	00000000 00000000 00000000 00000010    00000000 00000000 00000000 00000011
2.两位不相等为
	00000000 00000000 00000000 00000001
printf("%d\n",2^3); //1
```
# 位运算符
```c
1.算数右移 >> 低位溢出,符号位不变,并用符号位补溢出的高位
2.算数左移 << 符号位不变,低位补0
3.>>> 逻辑右移,无符号右移,低位溢出,高位补0
	0001 -> 0000
printf("%d\n",1>>2); // 0   x/2 n次
	0001 -> 0100
printf("%d\n",1<<2); //4    x*2 n次  1*2=n n*2 = 4
printf("%d\n",4<<3); //32    x*2 n次  4 * 2 * 2 * 2
	Java中 00000101 = 00000010
System.out.println(5>>>1); // 2
```
